//! Build script that embeds schema TOML files at compile time.
//!
//! Parses `data/messages.toml` to discover segment schema files, then generates
//! a Rust module with `include_str!` macros for all TOML content.
//!
//! # Generated Output
//!
//! Creates `$OUT_DIR/embedded_schemas.rs` containing:
//! - `MESSAGES_TOML: &str` - the full messages.toml content
//! - `SEGMENT_SCHEMAS: &[(&str, &str)]` - array of (segment_name, toml_content) tuples
//!
//! # Rebuild Triggers
//!
//! The build script emits `cargo:rerun-if-changed` for messages.toml and all segment
//! files, so modifying any schema file triggers recompilation.

use serde::Deserialize;
use std::{collections::HashMap, env, fs, path::Path};

/// Partial deserialisation of messages.toml to extract segment file mappings.
#[derive(Deserialize)]
struct MessagesConfig {
    segments: HashMap<String, String>,
}

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("can get CARGO_MANIFEST_DIR");
    let out_dir = env::var("OUT_DIR").expect("can get OUT_DIR");
    let data_dir = Path::new(&manifest_dir).join("data");

    let messages_path = data_dir.join("messages.toml");
    println!("cargo:rerun-if-changed={}", messages_path.display());

    let messages_content = fs::read_to_string(&messages_path).expect("can read data/messages.toml");
    let config: MessagesConfig =
        toml::from_str(&messages_content).expect("can parse data/messages.toml");

    // collect segment files and emit rerun-if-changed
    let mut segment_entries = Vec::new();
    for (segment_name, filename) in &config.segments {
        let segment_path = data_dir.join(filename);
        println!("cargo:rerun-if-changed={}", segment_path.display());

        if !segment_path.exists() {
            panic!(
                "segment schema file not found: {} (referenced by {})",
                segment_path.display(),
                segment_name
            );
        }

        segment_entries.push((segment_name.clone(), filename.clone()));
    }

    // sort for deterministic output
    segment_entries.sort_by(|a, b| a.0.cmp(&b.0));

    // generate the embedded schemas module with absolute paths
    let mut generated = String::new();
    generated.push_str("// auto-generated by build.rs - do not edit\n\n");
    generated.push_str("/// Embedded messages.toml content.\n");
    generated.push_str(&format!(
        "pub const MESSAGES_TOML: &str = include_str!(\"{}\");\n\n",
        messages_path.display()
    ));
    generated.push_str("/// Embedded segment schema TOML content, keyed by segment name.\n");
    generated.push_str("pub const SEGMENT_SCHEMAS: &[(&str, &str)] = &[\n");

    for (segment_name, filename) in &segment_entries {
        let segment_path = data_dir.join(filename);
        generated.push_str(&format!(
            "    (\"{}\", include_str!(\"{}\")),\n",
            segment_name,
            segment_path.display()
        ));
    }

    generated.push_str("];\n");

    let out_path = Path::new(&out_dir).join("embedded_schemas.rs");
    fs::write(&out_path, &generated).expect("can write embedded_schemas.rs");

    tauri_build::build();
}
